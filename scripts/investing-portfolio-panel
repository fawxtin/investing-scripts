#!/usr/bin/env python3

from time import sleep
import sys
import os
import random
import threading
from glob import glob
import curses
from collections import defaultdict
import json
import websocket
from queue import Queue

"""
https://finnhub.io/api/v1/forex/exchange?token=
https://finnhub.io/api/v1/forex/symbol?exchange=oanda&token=
"""

tmp_dir = os.environ['HOME'] + "/tmp/scrapy/"
tmp_files = glob(tmp_dir + "investing.com_portfolio*.json")

grid = defaultdict(lambda: dict(pair=dict(), order=0)) # by pairId

token = os.environ.get('FINNHUB_IO_TOKEN')
symbol_table = {1: 'FXPRO:1'}
symbol_table_inv = {v: k for k, v in symbol_table.items()}
queue_info_pairs = Queue()


def parse_jsonfile(filename):
    with open(filename, 'r') as freader:
        return json.load(freader)

def mount_grid(grid, content):
    max_order = max([x['order'] for x in grid.values()] or [0])
    for pair in content:
        if pair['pairId'] in grid: # update grid row values
            grid[pair['pairId']]['pair'] = pair
        else: # add new row
            max_order += 1
            grid[pair['pairId']]['order'] = max_order
            grid[pair['pairId']]['pair'] = pair


def string_row(row): # transform this function into a colored one!
    return "{: >15} {: >15} {: >15} {: >15} {: >15} {: >15} {: >15} {: >15}".format(*row)



def main(stdscr):
    def on_message(ws, message):
        refresh = False
        msg_obj = json.loads(message)
        if msg_obj.get('type', '') == 'trade':
            queue_info_pairs.put(msg_obj)
        else:
            queue_info_pairs.put(msg_obj)

    def on_error(ws, error):
        queue_info_pairs.put({"message": error, "type": "error"})

    def on_close(ws):
        print("### closed ###")

    def on_open(ws):
        subscriptions = "subcriptions: "
        for pair_id in grid.keys():
            subscription = '{"type":"subscribe","symbol":"FXPRO:' + str(pair_id) + '"}'
            subscriptions += subscription
            ws.send(subscription)
        queue_info_pairs.put({"message": subscriptions, "type": "subscription"})

    def print_grid_element(element):
        pair = element['pair']
        price = pair['priceLast']
        if type(price) == str:
            price = price.replace(',', '')
        if element['order'] < 50:
            stdscr.addstr(element['order'], 0,
                          string_row([pair['pairSymbol'] or pair['pairName'],
                                      '{:.4f}'.format(float(price)),
                                      pair['pricePrev'], pair['priceOpen'],
                                      pair['priceHigh'], pair['priceLow'],
                                      pair['priceChange'], pair['volume']]))
        
    def parse_message(message):
        if message.get("type", "") == "trade":
            for msg in message.get("data", []):
                pair_symbol = msg.get('s', '').split(':')
                if len(pair_symbol) == 2:
                    grid_pair = int(pair_symbol[1])
                    if grid_pair in grid:
                        grid[grid_pair]['pair']['priceLast'] = msg['p']
                        print_grid_element(grid[grid_pair])

    if len(sys.argv) == 1:
        sys.exit(1)
    
    tmp_portfolio_file = sys.argv[1]
    content = parse_jsonfile(tmp_portfolio_file)

    stdscr.clear()
    stdscr.addstr(0, 0, string_row(['Symbol/Name', 'Price', 'Prev', 'Open', 'High', 'Low', 'Change', 'Volume']))
    
    mount_grid(grid, content)
    for element in grid.values():
        print_grid_element(element)
    stdscr.refresh()
    #websocket.enableTrace(True)
    ws = websocket.WebSocketApp("wss://ws.finnhub.io?token=" + token,
                                on_message = on_message,
                                on_error = on_error,
                                on_close = on_close)
    ws.on_open = on_open
    wst = threading.Thread(target=ws.run_forever)
    wst.setDaemon(True)
    wst.start()
    count = 0
    while True:
        while queue_info_pairs.empty() == False:
            message = queue_info_pairs.get()
            parse_message(message)

        count += 1
        stdscr.refresh()
        sleep(3)


if __name__ == '__main__':
    curses.wrapper(main)

